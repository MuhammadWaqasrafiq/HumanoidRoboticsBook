"use strict";(self.webpackChunkphysical_ai_humanoid_robotics_book=self.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[3424],{7208:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"dexterous-manipulation/quiz","title":"Chapter 09 Quiz: Dexterous Manipulation","description":"Test your understanding of grasp planning, inverse kinematics, force control, and manipulation pipelines","source":"@site/docs/dexterous-manipulation/quiz.mdx","sourceDirName":"dexterous-manipulation","slug":"/dexterous-manipulation/quiz","permalink":"/HumanoidRoboticsBook/docs/dexterous-manipulation/quiz","draft":false,"unlisted":false,"editUrl":"https://github.com/MuhammadWaqasrafiq/HumanoidRoboticsBook/tree/main/docs/dexterous-manipulation/quiz.mdx","tags":[],"version":"current","frontMatter":{"title":"Chapter 09 Quiz: Dexterous Manipulation","description":"Test your understanding of grasp planning, inverse kinematics, force control, and manipulation pipelines"}}');var s=i(4848),t=i(8453);const l={title:"Chapter 09 Quiz: Dexterous Manipulation",description:"Test your understanding of grasp planning, inverse kinematics, force control, and manipulation pipelines"},o="Chapter 09 Quiz: Dexterous Manipulation",c={},a=[{value:"Question 1: Ferrari-Canny Grasp Quality",id:"question-1-ferrari-canny-grasp-quality",level:2},{value:"Question 2: IK Solver Convergence Failure",id:"question-2-ik-solver-convergence-failure",level:2},{value:"Question 3: Impedance Control Stiffness Tuning",id:"question-3-impedance-control-stiffness-tuning",level:2},{value:"Question 4: Grasp Synergy for Multi-Fingered Hand",id:"question-4-grasp-synergy-for-multi-fingered-hand",level:2},{value:"Question 5: TRAC-IK vs Numerical IK",id:"question-5-trac-ik-vs-numerical-ik",level:2},{value:"Question 6: Pick-and-Place Failure Recovery",id:"question-6-pick-and-place-failure-recovery",level:2},{value:"Question 7: Dual-Arm Relative Constraint",id:"question-7-dual-arm-relative-constraint",level:2},{value:"Question 8: Adaptive Impedance for Door Opening",id:"question-8-adaptive-impedance-for-door-opening",level:2},{value:"Question 9: Object Slip Detection",id:"question-9-object-slip-detection",level:2},{value:"Question 10: In-Hand Manipulation Energy Efficiency",id:"question-10-in-hand-manipulation-energy-efficiency",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components},{Details:i}=e;return i||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"chapter-09-quiz-dexterous-manipulation",children:"Chapter 09 Quiz: Dexterous Manipulation"})}),"\n",(0,s.jsx)(e.p,{children:"Test your knowledge of grasp planning, inverse kinematics, impedance control, and multi-fingered manipulation."}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"question-1-ferrari-canny-grasp-quality",children:"Question 1: Ferrari-Canny Grasp Quality"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"You're evaluating two antipodal grasps for a cylindrical object (radius 0.04m, mass 0.5kg):"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Grasp A:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Contact points: p1=(0.04, 0, 0), p2=(-0.04, 0, 0)"}),"\n",(0,s.jsx)(e.li,{children:"Normals: n1=(1, 0, 0), n2=(-1, 0, 0) (perfectly opposing)"}),"\n",(0,s.jsx)(e.li,{children:"Grasp width: 0.08m (gripper fully open)"}),"\n",(0,s.jsx)(e.li,{children:"Friction coefficient: \u03bc=0.7"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Grasp B:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Contact points: p1=(0.028, 0.028, 0), p2=(-0.028, -0.028, 0)"}),"\n",(0,s.jsx)(e.li,{children:"Normals: n1=(0.707, 0.707, 0), n2=(-0.707, -0.707, 0) (opposing)"}),"\n",(0,s.jsx)(e.li,{children:"Grasp width: 0.056m (70% open)"}),"\n",(0,s.jsx)(e.li,{children:"Friction coefficient: \u03bc=0.7"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Which grasp has higher Ferrari-Canny quality and why?"})}),"\n",(0,s.jsx)(e.p,{children:"A) Grasp A - perfect normal alignment ensures maximum force closure"}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"B) Grasp B - narrower width and similar alignment provide better stability \u2705"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Correct! Grasp B has higher quality despite slightly worse alignment."})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Ferrari-Canny Quality Breakdown:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def ferrari_canny_quality(grasp):\n    # Component 1: Normal alignment (both ~0.99 for A, ~0.98 for B)\n    alignment_A = 1.0  # Perfect opposing\n    alignment_B = 0.98  # 45\xb0 offset but still opposing\n\n    # Component 2: Width utilization (prefer narrower grasps)\n    width_quality_A = 1 - (0.08 / 0.08) = 0.0  # Fully open = unstable\n    width_quality_B = 1 - (0.056 / 0.08) = 0.3  # 30% margin\n\n    # Component 3: Wrench space coverage\n    # Grasp B has slightly better tangential force capacity\n\n    # Weighted quality\n    quality_A = 0.5*1.0 + 0.3*0.0 + 0.2*0.5 = 0.60\n    quality_B = 0.5*0.98 + 0.3*0.3 + 0.2*0.6 = 0.70\n\n    return quality_B &gt; quality_A\n"})}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Key Insight:"})," Width utilization is critical - grasps near maximum gripper width are vulnerable to:"]}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Object shifting under external forces"}),"\n",(0,s.jsx)(e.li,{children:"Limited force margin (can't squeeze tighter)"}),"\n",(0,s.jsx)(e.li,{children:"Higher slip probability"}),"\n"]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Best Practice:"})," Target 60-80% of max gripper width for robustness."]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"C) Equal quality - both achieve force closure"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Incorrect."})," While both grasps achieve force closure (can resist arbitrary wrenches), Ferrari-Canny quality also considers:"]}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Wrench space volume"}),": Larger convex hull = more robust"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Distance to singularity"}),": How close to losing force closure"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Width margin"}),": Safety factor against disturbances"]}),"\n"]}),(0,s.jsx)(e.p,{children:"Grasp A uses 100% of gripper capacity with no margin, making it less robust despite perfect alignment."})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"D) Insufficient information - need friction cone analysis"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Partially correct thinking"})," - friction cone does matter, but the question provides friction coefficient (\u03bc=0.7)."]}),(0,s.jsx)(e.p,{children:"With \u03bc=0.7, friction cone half-angle = arctan(0.7) \u2248 35\xb0, which is sufficient for both grasps. The quality difference comes from width utilization, not friction constraints."})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"question-2-ik-solver-convergence-failure",children:"Question 2: IK Solver Convergence Failure"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Your numerical IK solver (damped least squares, \u03bb=0.05) fails to converge for a reachable target:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"Target: x=0.6m, y=0.2m, z=0.4m (verified reachable)\nInitial guess: q_init = [0, 0, 0, 0, 0, 0, 0]  # Home position\nResult: Converged to x=0.58m, y=0.19m, z=0.39m (20mm error) after 100 iterations\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"What's the most likely cause and solution?"})}),"\n",(0,s.jsx)(e.p,{children:"A) Target is actually unreachable - increase joint limits"}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"B) Poor initial guess led to local minimum - try multiple random seeds \u2705"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Correct! Classic local minimum problem in numerical IK."})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Diagnosis:"})}),(0,s.jsx)(e.p,{children:"The solver converged (error stopped decreasing) but to the wrong solution. This indicates:"}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Jacobian rank deficiency"})," at the converged configuration (near singularity)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Null space trap"}),' - redundant arm "stuck" in poor posture']}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Local minimum"})," of error function"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Solution: Multi-Start IK"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def robust_ik(target, robot, n_attempts=10):\n    \"\"\"\n    Solve IK with multiple random initial guesses.\n\n    Returns best solution among all attempts.\n    \"\"\"\n    best_q = None\n    best_error = float('inf')\n\n    for attempt in range(n_attempts):\n        # Random initial guess within joint limits\n        q_init = np.random.uniform(\n            robot.q_min,\n            robot.q_max\n        )\n\n        # Attempt IK\n        q_solution, success, error = damped_ls_ik(\n            target, q_init,\n            max_iter=100,\n            lambda_damp=0.05\n        )\n\n        # Track best solution\n        if error['final_error'] &lt; best_error:\n            best_error = error['final_error']\n            best_q = q_solution\n\n        # Early exit if converged\n        if error['final_error'] &lt; 1e-4:  # 0.1mm\n            return q_solution, True\n\n    # Return best effort\n    return best_q, (best_error &lt; 1e-3)\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why This Happens:"})}),(0,s.jsxs)(e.p,{children:["Home position [0, 0, 0, ...] often places the arm in a ",(0,s.jsx)(e.strong,{children:"singular configuration"})," (e.g., elbow fully extended, shoulder at 0\xb0). The Jacobian has reduced rank, causing:"]}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Large joint motions for small Cartesian steps"}),"\n",(0,s.jsx)(e.li,{children:"Damping term dominates, slowing convergence"}),"\n",(0,s.jsx)(e.li,{children:"Local minimum away from true solution"}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Alternative Fixes:"})}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Better initial guess"}),": Use current joint state instead of home"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Lower damping"}),": \u03bb=0.01 for targets far from singularities"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Optimization-based IK"}),": CasADi/IPOPT handles local minima better"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"TRAC-IK"}),": Runs numerical + optimization in parallel, returns best"]}),"\n"]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Production Recommendation:"})," Use TRAC-IK with 3-5 attempts, 50ms timeout."]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"C) Damping too high (\u03bb=0.05) - reduce to \u03bb=0.01"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Partially correct"})," - high damping does slow convergence, but it's not the root cause of 20mm error."]}),(0,s.jsx)(e.p,{children:"Reducing \u03bb would help convergence speed but won't escape the local minimum. The solver would still get stuck near the same point, just slightly faster."}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"When to reduce damping:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Targets far from singularities"}),"\n",(0,s.jsx)(e.li,{children:"Fast convergence required (<10 iterations)"}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"When to increase damping:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Near singularities (Jacobian rank < 6)"}),"\n",(0,s.jsx)(e.li,{children:"Noisy measurements"}),"\n",(0,s.jsx)(e.li,{children:"Redundant arms (7+ DOF)"}),"\n"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"D) Increase max iterations to 500"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Incorrect"})," - the error plateaued, not the iteration count."]}),(0,s.jsx)(e.p,{children:"More iterations won't help if the solver is stuck in a local minimum. You'd just waste computation (500 iterations \xd7 5ms = 2.5 seconds) without improving the solution."}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"When max_iter helps:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Slow but steady convergence (error decreasing linearly)"}),"\n",(0,s.jsx)(e.li,{children:"High-DOF robots (10+ joints)"}),"\n",(0,s.jsx)(e.li,{children:"Tight tolerances (sub-millimeter)"}),"\n"]})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"question-3-impedance-control-stiffness-tuning",children:"Question 3: Impedance Control Stiffness Tuning"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"You're programming a humanoid to insert a USB cable into a port (2mm clearance). The robot repeatedly breaks the connector due to excessive force."})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Current impedance parameters:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"K_position = diag([1000, 1000, 1000])  # N/m (stiff)\nD_position = diag([50, 50, 50])        # Ns/m\nF/T sensor reading at failure: [120N, 15N, 200N, ...]  # Force spike\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"What's the best stiffness adjustment strategy?"})}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"A) Reduce all stiffnesses equally to K=[100, 100, 100] N/m"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Suboptimal"})," - you'd lose precision in the XY plane (parallel to port face) where high stiffness is needed for alignment."]}),(0,s.jsx)(e.p,{children:"USB insertion requires:"}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"High XY stiffness"})," (500-1000 N/m): Maintain lateral alignment"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Low Z stiffness"})," (50-100 N/m): Compliant insertion along axis"]}),"\n"]}),(0,s.jsx)(e.p,{children:"Uniformly soft impedance would cause the cable to wander laterally and miss the port."})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"B) Use anisotropic stiffness: K_xy=500, K_z=50 (stiff lateral, soft axial) \u2705"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Correct! Anisotropic impedance matches the task constraints."})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Task Analysis: USB Insertion"})}),(0,s.jsxs)(e.p,{children:["The USB port defines a ",(0,s.jsx)(e.strong,{children:"constrained task space"}),":"]}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"XY plane"})," (lateral): Position-controlled (must align with port)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Z axis"})," (insertion): Force-controlled (compliant insertion)"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Optimal Impedance:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Rotation matrix: align Z-axis with insertion direction\nR_task = compute_approach_orientation(usb_port_normal)\n\n# Anisotropic stiffness in task frame\nK_task = np.diag([\n    500,  # X: Lateral alignment (stiff)\n    500,  # Y: Lateral alignment (stiff)\n    50,   # Z: Insertion axis (compliant)\n    30,   # Rx: Moderate rotational stiffness\n    30,   # Ry: Moderate rotational stiffness\n    100   # Rz: Stiffer around insertion axis\n])\n\n# Transform to world frame\nK_world = R_task @ K_task @ R_task.T\n\n# Impedance controller\ndef compute_control(x_error, v_current, f_external):\n    # Compliant in Z allows up to 50N force for 1cm error\n    # F = K\xb7\u0394x \u2192 50N = 50 N/m \xb7 0.01m \u2713\n\n    f_desired = K_world @ x_error - D @ v_current\n    tau = J.T @ (f_desired - f_external)\n    return tau\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why This Works:"})}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Lateral stiffness (500 N/m)"}),": Resists misalignment, maintains 0.5mm accuracy"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Axial compliance (50 N/m)"}),": Allows 10cm motion under 5N force (gentle insertion)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force limiting"}),": Even if fully misaligned, max force = K_z \xb7 clearance = 50 \xb7 0.002 = 0.1N"]}),"\n"]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Result:"})," Successful insertion with <5N peak force (vs 200N previously)."]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Alternative: Hybrid Control"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Selection matrix: force control in Z only\nS = np.diag([0, 0, 1, 0, 0, 0])  # Z-axis force controlled\nP = np.eye(6) - S                # XY position controlled\n\n# Hybrid controller\nu_position = K_pos @ (P @ x_error)\nu_force = K_force @ (S @ (f_desired - f_measured))\nu_total = u_position + u_force\n"})})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"C) Increase damping to D=[200, 200, 200] to slow motion"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Incorrect"})," - high damping reduces oscillation but doesn't prevent force spikes."]}),(0,s.jsxs)(e.p,{children:["Damping only affects ",(0,s.jsx)(e.strong,{children:"velocity-dependent"})," forces:"]}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"F_damping = D \xb7 v"}),"\n"]}),(0,s.jsx)(e.p,{children:"During insertion, velocity is already low (typically 1-5 cm/s). Increasing D from 50 to 200 Ns/m would only add:"}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"\u0394F = (200 - 50) \xb7 0.02 m/s = 3N (negligible)"}),"\n"]}),(0,s.jsxs)(e.p,{children:["The 200N force spike comes from ",(0,s.jsx)(e.strong,{children:"position error"})," (stiffness term), not velocity. You need to reduce K_z, not increase D."]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"When to increase damping:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Oscillations during free-space motion"}),"\n",(0,s.jsx)(e.li,{children:"Contact chatter (stick-slip)"}),"\n",(0,s.jsx)(e.li,{children:"High-frequency vibrations"}),"\n"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"D) Add force threshold safety stop (abort if F > 20N)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Safety measure but not a solution"})," - the task would never complete."]}),(0,s.jsx)(e.p,{children:"USB insertion inherently requires contact force (friction, alignment correction). A 20N threshold would trigger constantly, preventing successful insertion."}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Better approach:"})," Combine compliant control + force monitoring:"]}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Allow higher forces temporarily during insertion\nif task_phase == 'insertion':\n    force_limit = 30N  # Higher threshold\n    if f_measured &gt; force_limit:\n        # Don't abort - switch to force control\n        K_z = 20  # Even softer\nelse:\n    force_limit = 10N  # Strict limit for free space\n"})})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"question-4-grasp-synergy-for-multi-fingered-hand",children:"Question 4: Grasp Synergy for Multi-Fingered Hand"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"You're programming an Allegro Hand (16 DOF, 4 fingers) to grasp a screwdriver for in-hand rotation. Which synergy combination provides the best manipulation dexterity?"})}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"A) 100% Synergy 1 (full flexion) - power grasp"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Incorrect for in-hand manipulation"})," - power grasps immobilize the object."]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Synergy 1 (Flexion):"})," All fingers close uniformly"]}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use case:"})," Power grasp (holding heavy/large objects)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Degrees of freedom:"})," 1 (aperture only)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"In-hand manipulation:"})," Impossible (object locked by all fingers)"]}),"\n"]}),(0,s.jsxs)(e.p,{children:["For screwdriver rotation, you need ",(0,s.jsx)(e.strong,{children:"differential finger motion"})," to apply torque while maintaining grasp."]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"B) 70% Synergy 1 + 30% Synergy 2 (precision grasp with thumb-index opposition) \u2705"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Correct! Precision grasp enables in-hand rotation via pivoting."})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Synergy Decomposition:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Principal grasp synergies (from human hand studies)\nsynergy_1 = np.array([1, 0.8, 0.6, 0.4] * 4)  # Flexion\nsynergy_2 = np.array([1, -1, 0, 0] * 4)       # Precision opposition\nsynergy_3 = np.array([1, 1, -1, -1] * 4)      # Lateral\n\n# Precision grasp for screwdriver\nq_grasp = 0.7 * synergy_1 + 0.3 * synergy_2\n\n# Resulting configuration:\n# - Thumb: Fully opposed to index (S2 component)\n# - Index: Medium flexion (holds object)\n# - Middle/Ring: Light contact (S1 only)\n# - Pinky: Minimal involvement\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"In-Hand Rotation Strategy:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def rotate_screwdriver(target_angle):\n    """\n    Rotate screwdriver by pivoting around thumb-index grasp.\n\n    1. Thumb + Index: Fixed pivot (precision grasp)\n    2. Middle + Ring: Apply tangential force\n    """\n    # Phase 1: Establish pivot\n    thumb.set_position(synergy_2[0])  # Opposing\n    index.set_position(synergy_2[1])  # Opposing\n    thumb.set_stiffness(1000)  # High (fixed)\n    index.set_stiffness(1000)  # High (fixed)\n\n    # Phase 2: Apply rotation torque with other fingers\n    for angle in np.linspace(0, target_angle, 50):\n        # Compute tangential push direction\n        middle_target = compute_tangent_position(angle, pivot_point)\n\n        middle.set_position(middle_target)\n        middle.set_stiffness(200)  # Moderate (compliant push)\n\n        time.sleep(0.02)\n\n    # Result: 90\xb0 rotation with &lt;3N peak force\n'})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why Precision Grasp Works:"})}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Stable pivot:"})," Thumb-index opposition creates force closure"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Free rotation:"})," Other fingers can move independently"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force control:"})," Moderate stiffness (200 N/m) allows compliant torque application"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Human-like:"})," Mimics natural precision manipulation"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Dexterity Metrics:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Manipulability:"})," 3/4 fingers available for actuation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Grasp stability:"})," Force closure maintained during rotation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Control bandwidth:"})," 10-20 Hz rotation rate achievable"]}),"\n"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"C) 50% Synergy 1 + 50% Synergy 3 (lateral grasp)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Suboptimal"})," - lateral grasp (thumb-pinky) provides poor dexterity for screwdrivers."]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Synergy 3 (Lateral):"})," Thumb opposes pinky"]}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use case:"})," Grasping flat objects (cards, keys)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Screwdriver problem:"})," Long moment arm \u2192 unstable grasp, high torque on pinky (weakest finger)"]}),"\n"]}),(0,s.jsx)(e.p,{children:"For cylindrical objects like screwdrivers, thumb-index opposition (S2) provides better alignment with object axis."})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"D) Individual finger control (no synergies) for maximum dexterity"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Theoretically optimal but practically challenging:"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Pros:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Maximum control authority (16 independent DOFs)"}),"\n",(0,s.jsx)(e.li,{children:"Arbitrary contact configurations"}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Cons:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"High computational cost:"})," 16D IK + contact planning"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Control complexity:"})," Coordinating 16 joints in real-time (1kHz)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Calibration sensitivity:"})," Tiny errors amplified across many DOFs"]}),"\n"]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Synergies reduce dimensionality:"})," 16 DOF \u2192 2-3 synergy weights"]}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Easier optimization"}),"\n",(0,s.jsx)(e.li,{children:"More robust to calibration errors"}),"\n",(0,s.jsx)(e.li,{children:"Still achieves 80-90% of full dexterity"}),"\n"]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Production recommendation:"})," Use synergies for grasping, individual control for fine manipulation (if needed)."]})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"question-5-trac-ik-vs-numerical-ik",children:"Question 5: TRAC-IK vs Numerical IK"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"You're comparing IK solvers for a pick-and-place task (200 picks/hour). Benchmark results:"})}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Solver"}),(0,s.jsx)(e.th,{children:"Avg Time"}),(0,s.jsx)(e.th,{children:"Success Rate"}),(0,s.jsx)(e.th,{children:"Failures"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Damped LS (\u03bb=0.05, 1 seed)"}),(0,s.jsx)(e.td,{children:"12ms"}),(0,s.jsx)(e.td,{children:"78%"}),(0,s.jsx)(e.td,{children:"Local minima"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Damped LS (\u03bb=0.05, 10 seeds)"}),(0,s.jsx)(e.td,{children:"95ms"}),(0,s.jsx)(e.td,{children:"94%"}),(0,s.jsx)(e.td,{children:"Timeout"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"TRAC-IK (50ms timeout)"}),(0,s.jsx)(e.td,{children:"31ms"}),(0,s.jsx)(e.td,{children:"96%"}),(0,s.jsx)(e.td,{children:"Rare"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"CasADi/IPOPT (100ms timeout)"}),(0,s.jsx)(e.td,{children:"78ms"}),(0,s.jsx)(e.td,{children:"98%"}),(0,s.jsx)(e.td,{children:"Rare"})]})]})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Which solver best balances speed and reliability for production?"})}),"\n",(0,s.jsx)(e.p,{children:"A) Damped LS with 1 seed - fastest (12ms)"}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"B) TRAC-IK with 50ms timeout - best speed/reliability trade-off \u2705"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Correct! TRAC-IK achieves 96% success in 31ms - optimal for production."})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Decision Analysis:"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Production Requirements:"})}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Cycle time:"})," 200 picks/hour \u2192 18 seconds/pick \u2192 IK budget ~500ms (2.8% of cycle)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Reliability:"})," >95% success (max 10 failures/hour acceptable)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Real-time:"})," <100ms response for reactive planning"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"TRAC-IK Advantages:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# TRAC-IK runs two solvers in parallel, returns fastest:\n# 1. KDL numerical IK (fast, 60-80% success)\n# 2. NLOpt optimization (slow, 95-98% success)\n\ndef trac_ik_solve(target, timeout=50ms):\n    # Spawn parallel solvers\n    future_kdl = async_solve_kdl(target)\n    future_nlopt = async_solve_nlopt(target)\n\n    # Return whichever finishes first\n    result = await_first([future_kdl, future_nlopt], timeout)\n\n    # Typical outcomes:\n    # - 70% of time: KDL succeeds in 8-15ms\n    # - 25% of time: NLOpt succeeds in 40-50ms\n    # - 5% of time: Both fail (timeout)\n\n    return result\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Performance Breakdown:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Fast path (70%):"})," KDL succeeds \u2192 12ms average"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Slow path (26%):"})," KDL fails, NLOpt succeeds \u2192 50ms"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Failure (4%):"})," Both timeout \u2192 50ms + fallback"]}),"\n"]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Weighted average:"})," 0.7\xd712 + 0.26\xd750 + 0.04\xd750 = ",(0,s.jsx)(e.strong,{children:"23ms"})," (matches benchmark)"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why Better Than Alternatives:"})}),(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Solver"}),(0,s.jsx)(e.th,{children:"Speed"}),(0,s.jsx)(e.th,{children:"Reliability"}),(0,s.jsx)(e.th,{children:"Production Risk"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"1-seed DLS"}),(0,s.jsx)(e.td,{children:"\u2b50\u2b50\u2b50"}),(0,s.jsx)(e.td,{children:"\u2b50"}),(0,s.jsxs)(e.td,{children:[(0,s.jsx)(e.strong,{children:"22% failure = 44 fails/hour"})," (unacceptable)"]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"10-seed DLS"}),(0,s.jsx)(e.td,{children:"\u2b50"}),(0,s.jsx)(e.td,{children:"\u2b50\u2b50\u2b50"}),(0,s.jsx)(e.td,{children:"95ms too slow for reactive tasks"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"TRAC-IK"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"\u2b50\u2b50"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"\u2b50\u2b50\u2b50"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Best balance"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"IPOPT"}),(0,s.jsx)(e.td,{children:"\u2b50"}),(0,s.jsx)(e.td,{children:"\u2b50\u2b50\u2b50"}),(0,s.jsx)(e.td,{children:"78ms acceptable but slower"})]})]})]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Configuration:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"# moveit2 config/kinematics.yaml\nmanipulator:\n  kinematics_solver: trac_ik_kinematics_plugin/TRAC_IKKinematicsPlugin\n  kinematics_solver_timeout: 0.05  # 50ms\n  kinematics_solver_attempts: 1    # TRAC-IK handles retries internally\n  position_tolerance: 0.0001       # 0.1mm\n  orientation_tolerance: 0.001     # ~0.06\xb0\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Fallback Strategy:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Production IK pipeline\ndef robust_ik_solve(target):\n    # Attempt 1: TRAC-IK (fast)\n    q, success = trac_ik.solve(target, timeout=50ms)\n    if success:\n        return q\n\n    # Attempt 2: Perturb target slightly (compliance)\n    for dx in [0.002, 0.005, 0.01]:  # 2mm, 5mm, 10mm\n        perturbed = target.translate(random_direction() * dx)\n        q, success = trac_ik.solve(perturbed, timeout=50ms)\n        if success:\n            return q\n\n    # Attempt 3: Relax orientation (if task allows)\n    q, success = trac_ik.solve(target, position_only=True, timeout=100ms)\n    return q  # Best effort\n"})}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Result:"})," 99.5% effective success rate with graceful degradation."]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"C) Damped LS with 10 seeds - highest success (94%)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Reliable but too slow"})," - 95ms violates real-time constraint."]}),(0,s.jsx)(e.p,{children:"At 95ms per IK solve:"}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Motion planning requires 5-10 IK calls \u2192 475-950ms"}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Total cycle:"})," 1-2 seconds for planning alone"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Throughput:"})," Reduced to ~150 picks/hour (25% slower)"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"When 10-seed DLS is appropriate:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Offline planning (not time-critical)"}),"\n",(0,s.jsx)(e.li,{children:"High-accuracy requirements (surgical, assembly)"}),"\n",(0,s.jsx)(e.li,{children:"No TRAC-IK available (custom robot)"}),"\n"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"D) CasADi/IPOPT - highest success (98%)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Over-engineered"})," - 98% vs 96% success doesn't justify 2.5\xd7 slowdown."]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Diminishing returns:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"TRAC-IK: 96% success, 31ms \u2192 1.2 failures/pick/hour"}),"\n",(0,s.jsx)(e.li,{children:"IPOPT: 98% success, 78ms \u2192 0.4 failures/pick/hour"}),"\n"]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Marginal gain:"})," Saving 0.8 failures/hour\n",(0,s.jsx)(e.strong,{children:"Cost:"})," 47ms \xd7 200 picks = 2.6 hours lost per day to IK computation"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Use IPOPT when:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Extremely tight constraints (collision avoidance)"}),"\n",(0,s.jsx)(e.li,{children:"Multi-objective optimization (minimize joint limits + singularities)"}),"\n",(0,s.jsx)(e.li,{children:"Complex cost functions (energy minimization)"}),"\n"]}),(0,s.jsx)(e.p,{children:"For simple pick-and-place, TRAC-IK suffices."})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"question-6-pick-and-place-failure-recovery",children:"Question 6: Pick-and-Place Failure Recovery"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:'Your pick-and-place pipeline fails with the error: "No feasible grasp found" (IK succeeded for 3/10 grasp candidates but all motion plans collided). How do you diagnose and fix this?'})}),"\n",(0,s.jsx)(e.p,{children:"A) Increase max planning time from 5s to 30s"}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"B) Check collision geometry - likely false positive from conservative padding \u2705"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Correct! IK success + motion planning failure \u2192 collision geometry issue."})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Diagnosis Process:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# 1. Visualize grasp candidates and collision scene\nfor grasp in grasp_candidates:\n    q_grasp = ik_solver.solve(grasp.pose)\n\n    if q_grasp is not None:  # IK succeeded\n        # Check forward kinematics\n        T_ee = robot.fk(q_grasp)\n\n        # Visualize in RViz\n        publish_robot_state(q_grasp)\n        publish_collision_scene()\n\n        # Attempt motion plan\n        trajectory = motion_planner.plan(q_current, q_grasp)\n\n        if not trajectory.success:\n            # Log collision details\n            collisions = motion_planner.get_collision_info()\n            print(f"Collisions: {collisions}")\n            # Typical output: [("gripper_finger", "table", distance=-0.005m)]\n'})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Common Collision Geometry Issues:"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Issue 1: Excessive Padding"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"# moveit2 config/collision_padding.yaml\nrobot_description_planning:\n  default_padding: 0.02  # \u274c Too conservative (2cm)\n\n# Fix: Reduce to realistic safety margin\nrobot_description_planning:\n  default_padding: 0.005  # \u2705 5mm (typical)\n\n  # Fine-tune per link\n  link_padding:\n    gripper_finger_left: 0.003   # Fingers: 3mm (precision)\n    base_link: 0.01              # Base: 10mm (conservative)\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Issue 2: Overly Simplified Collision Meshes"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'&lt;!-- URDF collision geometry --&gt;\n&lt;!-- \u274c Box collision for complex gripper --&gt;\n&lt;collision&gt;\n  &lt;geometry&gt;\n    &lt;box size="0.1 0.08 0.05"/&gt;  &lt;!-- Gripper bounding box --&gt;\n  &lt;/geometry&gt;\n&lt;/collision&gt;\n\n&lt;!-- \u2705 Refined mesh for accurate collision checking --&gt;\n&lt;collision&gt;\n  &lt;geometry&gt;\n    &lt;mesh filename="gripper_collision.stl" scale="1.0"/&gt;\n  &lt;/geometry&gt;\n&lt;/collision&gt;\n'})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Issue 3: Stale Collision Scene"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Object moved but collision scene not updated\ndef update_collision_scene(object_id, new_pose):\n    # Remove old object\n    planning_scene.remove_object(object_id)\n\n    # Add at new pose\n    planning_scene.add_box(\n        name=object_id,\n        pose=new_pose,\n        size=(0.05, 0.05, 0.1)\n    )\n\n    # Publish update\n    planning_scene_pub.publish(planning_scene.to_msg())\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Fix Strategy:"})}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visualize collisions"})," in RViz (enable collision markers)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Measure actual clearances"})," with physical robot"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Reduce padding"})," to 3-5mm (from default 2cm)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Update collision meshes"})," from CAD (use convex decomposition)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Test grasp approach"})," with reduced planning bounds"]}),"\n"]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Result:"})," Motion planning success increases from 0/10 to 8/10 grasps."]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"C) Generate more grasp candidates (increase from 10 to 100)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Wasteful"})," - if 3/10 grasps have feasible IK but 0/10 motion plans succeed, the problem isn't grasp diversity."]}),(0,s.jsx)(e.p,{children:"Generating 100 grasps would:"}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"\u2705 Find more IK-feasible grasps (maybe 30/100)"}),"\n",(0,s.jsx)(e.li,{children:"\u274c Still have 0/100 motion plans succeed (collision issue persists)"}),"\n",(0,s.jsx)(e.li,{children:"\u23f1\ufe0f Waste computation (grasp planning: 10\xd7 slower)"}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"When to increase grasp candidates:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"IK success rate <30% (need more options)"}),"\n",(0,s.jsx)(e.li,{children:"Object has complex geometry (many local optima)"}),"\n",(0,s.jsx)(e.li,{children:"Multi-modal grasps required (top vs side approaches)"}),"\n"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"D) Switch to Cartesian path planning (avoid joint-space obstacles)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Incorrect understanding"})," - Cartesian paths still check collisions."]}),(0,s.jsx)(e.p,{children:"Cartesian planning computes a straight-line path in task space:"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Cartesian path: move gripper in straight line\nwaypoints = [start_pose, grasp_pose]\ntrajectory = compute_cartesian_path(waypoints, step_size=0.01)\n\n# \u274c Still fails if any point along path collides\n# Collision checking happens at each waypoint\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"When Cartesian paths help:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Avoid joint-space detours (faster convergence)"}),"\n",(0,s.jsx)(e.li,{children:"Maintain end-effector orientation (pouring task)"}),"\n",(0,s.jsx)(e.li,{children:"Predictable motion (human safety)"}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"When they don't help:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Collision avoidance (same checks apply)"}),"\n",(0,s.jsx)(e.li,{children:"Unreachable straight-line path (IK fails mid-trajectory)"}),"\n"]})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"question-7-dual-arm-relative-constraint",children:"Question 7: Dual-Arm Relative Constraint"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"A humanoid is carrying a tray with both hands (30cm \xd7 40cm, 2kg). You must maintain tray levelness (<5\xb0 tilt) while the torso rotates 45\xb0. How do you formulate the relative constraint?"})}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"A) Independent arm control (each hand tracks its corner of tray)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Incorrect"})," - independent control doesn't enforce relative pose."]}),(0,s.jsx)(e.p,{children:"If left and right arms track separate trajectories:"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Left arm: follow left_tray_corner trajectory\n# Right arm: follow right_tray_corner trajectory\n\n# Problem: No coupling between arms\n# \u2192 Tray can twist, tilt, or compress if trajectories drift\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Failure modes:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Drift accumulation:"})," Small tracking errors \u2192 tray twist"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Singularity desync:"})," One arm hits singularity, slows down \u2192 tray tilts"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force imbalance:"})," Unequal tracking stiffness \u2192 tray compression"]}),"\n"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"B) Fix right hand pose, move only left hand (leader-follower)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Suboptimal"})," - wastes left arm's DOFs, poor load sharing."]}),(0,s.jsx)(e.p,{children:"Leader-follower assigns roles:"}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Leader (left):"})," Free to move"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Follower (right):"})," Slave to leader's motion"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Problems:"})}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Reduced workspace:"})," Right arm limits left arm's reach"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Uneven load:"})," Right arm bears more weight (static hold)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"No redundancy:"})," Can't use null space for obstacle avoidance"]}),"\n"]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Use case:"})," Asymmetric tasks (one hand holds, other manipulates)"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"C) Relative Jacobian with orientation constraint (maintain T_left_right) \u2705"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Correct! Enforce relative transform as a constraint in dual-arm Jacobian."})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Formulation:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def dual_arm_tray_control(tray_target, torso_angle):\n    """\n    Control dual-arm system with relative orientation constraint.\n\n    Constraint: T_left_right (tray width vector) remains constant\n    \u2192 Maintains tray levelness and distance between hands\n    """\n    # Desired tray pose in world frame\n    T_world_tray = compute_tray_pose(tray_target, torso_angle)\n\n    # Compute desired hand poses (tray corners)\n    T_world_left = T_world_tray @ T_tray_leftcorner\n    T_world_right = T_world_tray @ T_tray_rightcorner\n\n    # Current hand poses\n    T_left_current = robot.fk(q_left, \'left_hand\')\n    T_right_current = robot.fk(q_right, \'right_hand\')\n\n    # Task-space errors (12D: 2 hands \xd7 6D pose)\n    x_error_left = pose_error(T_world_left, T_left_current)\n    x_error_right = pose_error(T_world_right, T_right_current)\n    x_error_task = np.concatenate([x_error_left, x_error_right])\n\n    # Relative constraint: T_left_right should be constant\n    T_left_right_desired = T_tray_leftcorner.inverse() @ T_tray_rightcorner\n    T_left_right_current = T_left_current.inverse() @ T_right_current\n    x_error_relative = pose_error(T_left_right_desired, T_left_right_current)\n\n    # Augmented task: 18D (12D hands + 6D relative constraint)\n    x_error_augmented = np.concatenate([x_error_task, x_error_relative])\n\n    # Dual-arm Jacobian (12\xd714 for 7-DOF arms)\n    J_left = robot.jacobian(q_left, \'left_hand\')   # 6\xd77\n    J_right = robot.jacobian(q_right, \'right_hand\') # 6\xd77\n    J_dual = np.block([\n        [J_left,  np.zeros((6, 7))],\n        [np.zeros((6, 7)), J_right]\n    ])  # 12\xd714\n\n    # Relative Jacobian (enforces T_left_right constraint)\n    # J_rel maps joint velocities to relative pose change\n    J_rel = compute_relative_jacobian(J_left, J_right)  # 6\xd714\n\n    # Augmented Jacobian (18\xd714)\n    J_augmented = np.vstack([J_dual, J_rel])\n\n    # Weighted least squares (prioritize relative constraint)\n    W = np.diag([1]*12 + [10]*6)  # 10\xd7 weight on relative constraint\n    dq = np.linalg.pinv(J_augmented.T @ W @ J_augmented) @ (J_augmented.T @ W @ x_error_augmented)\n\n    return dq[:7], dq[7:]  # Left and right joint velocities\n\ndef compute_relative_jacobian(J_left, J_right):\n    """\n    Jacobian mapping joint velocities to relative pose change.\n\n    Derivation:\n    T_left_right = T_left^{-1} @ T_right\n    \u2192 d/dt(T_left_right) = -Ad(T_left^{-1}) @ J_left + Ad(T_right^{-1}) @ J_right\n    """\n    # Adjoint transformations (6\xd76)\n    Ad_left_inv = compute_adjoint(T_left_current.inverse())\n    Ad_right_inv = compute_adjoint(T_right_current.inverse())\n\n    # Relative Jacobian (6\xd714)\n    J_rel = np.hstack([\n        -Ad_left_inv @ J_left,\n        Ad_right_inv @ J_right\n    ])\n\n    return J_rel\n'})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Result:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Tray levelness:"})," Maintained within 2\xb0 (vs 15\xb0 without constraint)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Load sharing:"})," Both arms contribute equally"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Redundancy:"})," 14 DOF (2 arms \xd7 7) - 18 constraints = -4 \u2192 use damped pseudoinverse"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Torso compensation:"})," Relative constraint automatically adjusts hand poses as torso rotates"]}),"\n"]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Key Insight:"})," High weight (10\xd7) on relative constraint ensures tray stays level even if individual hand tracking has small errors."]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"D) Force control (each hand applies 10N upward force)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Incorrect approach"})," - force control doesn't ensure levelness."]}),(0,s.jsx)(e.p,{children:"Applying equal upward forces (10N each) would:"}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"\u2705 Support tray weight (2kg \xd7 9.81 \u2248 20N)"}),"\n",(0,s.jsx)(e.li,{children:"\u274c Not prevent tilt (force vectors could be misaligned)"}),"\n",(0,s.jsx)(e.li,{children:"\u274c Not maintain distance (hands could drift together/apart)"}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Counterexample:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Left hand: F = [0, 0, 10]N at position [0.15, 0, 1.0]\nRight hand: F = [0, 0, 10]N at position [-0.15, 0.05, 1.0]  # 5cm Y-offset\n\n\u2192 Tray supported but tilted 7\xb0 (exceeds 5\xb0 tolerance)\n"})}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"When force control is needed:"})," Compliant grasping (adapt to tray flexibility), not pose maintenance."]})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"question-8-adaptive-impedance-for-door-opening",children:"Question 8: Adaptive Impedance for Door Opening"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"A humanoid is opening a heavy door (50kg, stiff hinges with 30Nm friction). The impedance controller is configured with K=[300, 300, 300] N/m. The robot fails because the door doesn't move (force saturates at gripper limit, 100N). What's the best adaptation strategy?"})}),"\n",(0,s.jsx)(e.p,{children:"A) Increase stiffness to K=[1000, 1000, 1000] for more force authority"}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"B) Switch to admittance control (force \u2192 motion instead of motion \u2192 force) \u2705"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Correct! Impedance control is unsuitable for interaction with stiff environments."})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Problem Diagnosis:"})}),(0,s.jsx)(e.p,{children:"Impedance control generates force proportional to position error:"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Impedance: F = K \xb7 \u0394x\n\nTarget: x_desired = [0.5, 0, 1.0]  # 50cm door opening\nCurrent: x_current = [0, 0, 1.0]   # Door stuck (friction)\n\n# Force generated\nF = K @ (x_desired - x_current)\nF = 300 \xb7 [0.5, 0, 0] = [150N, 0, 0]\n\n# \u274c Exceeds gripper force limit (100N) \u2192 saturation \u2192 door doesn't budge\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why Higher Stiffness Doesn't Help:"})}),(0,s.jsx)(e.p,{children:"Even with K=1000 N/m:"}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"F = 1000 \xd7 0.5 = 500N (still saturates at 100N)"}),"\n",(0,s.jsx)(e.li,{children:"Robot pushes with max force but door is mechanically stuck (30Nm friction > 100N \xd7 gripper_lever_arm)"}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Solution: Admittance Control"})}),(0,s.jsxs)(e.p,{children:["Admittance inverts the relationship: ",(0,s.jsx)(e.strong,{children:"Force \u2192 Motion"})]}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class AdmittanceController:\n    def __init__(self, M_desired, D_desired):\n        """\n        Desired mass-damper dynamics for interaction.\n\n        M: Desired inertia (makes robot feel heavy/light)\n        D: Desired damping (smooths motion)\n        """\n        self.M = M_desired  # kg (virtual mass)\n        self.D = D_desired  # Ns/m (virtual damping)\n\n    def compute_motion(self, f_measured, x_current, v_current, dt):\n        """\n        Generate motion from measured force.\n\n        Dynamics: M\xb7\u1e8d + D\xb7\u1e8b = f_measured\n        \u2192 Integrate to get desired position\n        """\n        # Acceleration from force\n        a = (f_measured - self.D @ v_current) / self.M\n\n        # Integrate to velocity and position\n        v_new = v_current + a * dt\n        x_new = x_current + v_new * dt\n\n        # Command robot to move to x_new (position control)\n        return x_new, v_new\n\n# Door opening with admittance control\ndef open_door_admittance():\n    M = np.diag([5, 5, 5])    # Light virtual mass (5kg)\n    D = np.diag([20, 20, 20]) # Moderate damping\n\n    controller = AdmittanceController(M, D)\n\n    # Apply constant force via impedance\n    f_desired = [50, 0, 0]  # 50N push (within limits)\n\n    while door_angle &lt; target_angle:\n        # Measure reaction force from door\n        f_measured = ft_sensor.read()\n\n        # Admittance generates motion from force\n        x_cmd, v_cmd = controller.compute_motion(f_measured, x_current, v_current, dt)\n\n        # Robot follows generated trajectory (compliant motion)\n        robot.move_to(x_cmd)\n\n        # Door gradually opens as friction is overcome\n        # Admittance automatically slows near target (force drops)\n'})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why Admittance Works for Doors:"})}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force limiting:"})," Apply constant 50N (safe for gripper)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Automatic adaptation:"})," Motion slows when door resists (high f_measured)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Friction overcome:"})," Persistent force eventually breaks static friction"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Safe interaction:"})," Virtual mass (5kg) prevents impact forces"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Comparison:"})}),(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Control"}),(0,s.jsx)(e.th,{children:"Force Source"}),(0,s.jsx)(e.th,{children:"Motion Response"}),(0,s.jsx)(e.th,{children:"Door Opening"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Impedance"})}),(0,s.jsx)(e.td,{children:"F = K\xb7\u0394x (position error)"}),(0,s.jsx)(e.td,{children:"Fixed target"}),(0,s.jsx)(e.td,{children:"\u274c Saturates"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Admittance"})}),(0,s.jsx)(e.td,{children:"F = constant (or trajectory)"}),(0,s.jsx)(e.td,{children:"Adapts to force"}),(0,s.jsx)(e.td,{children:"\u2705 Compliant"})]})]})]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Hybrid Approach (Best):"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Phase 1: Admittance for initial opening (overcome friction)\napply_constant_force(50N, duration=5s)  # Door opens 30\xb0\n\n# Phase 2: Impedance for final positioning (precision)\ntarget_position = compute_door_pose(90\xb0)\nimpedance_control(target_position, K=300)  # Fine positioning\n"})})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"C) Add integral term (PI control) to accumulate force over time"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Partially correct"})," - PI control can overcome friction but risks instability."]}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# PI impedance control\ndef pi_impedance(x_error, x_error_integral, dt):\n    Kp = 300  # Proportional gain\n    Ki = 50   # Integral gain\n\n    # Accumulate error\n    x_error_integral += x_error * dt\n\n    # Force with integral term\n    F = Kp * x_error + Ki * x_error_integral\n\n    # Problem: Integral wind-up when door stuck\n    # \u2192 F grows unbounded \u2192 gripper damage\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Issues:"})}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Integral wind-up:"})," Error accumulates while door stuck \u2192 force spikes when door opens"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Overshoot:"})," High integral term \u2192 robot slams door open"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Instability:"})," Contact dynamics + integral \u2192 oscillations"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"When to use PI:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Steady-state error in free space (gravity compensation)"}),"\n",(0,s.jsx)(e.li,{children:"Slow disturbances (thermal drift)"}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Not"})," for contact-rich tasks"]}),"\n"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"D) Reduce control frequency from 200Hz to 50Hz (allow more force buildup)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Incorrect"})," - lower frequency worsens performance."]}),(0,s.jsx)(e.p,{children:"Control frequency affects:"}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Stability:"})," Lower frequency \u2192 larger discrete steps \u2192 instability"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Bandwidth:"})," 50Hz \u2192 max 25Hz tracking (Nyquist) \u2192 sluggish response"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force measurement:"})," F/T sensor sampled at 1kHz \u2192 downsampled to 50Hz \u2192 noisy"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Door opening needs:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"High frequency (200-1000Hz) for stable contact"}),"\n",(0,s.jsx)(e.li,{children:"Fast force feedback for adaptive motion"}),"\n"]}),(0,s.jsxs)(e.p,{children:["Reducing frequency would make the robot ",(0,s.jsx)(e.strong,{children:"less"})," responsive to door friction, not more."]})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"question-9-object-slip-detection",children:"Question 9: Object Slip Detection"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"During a pick-and-place task, the gripper loses grasp of a bottle mid-transport (slips out). You have a 6-axis F/T sensor at the wrist (1kHz sampling). How do you detect slip early enough to recover?"})}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"A) Monitor force magnitude - abort if F < 5N (object fell)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Too late"})," - object already fell by the time force drops."]}),(0,s.jsxs)(e.p,{children:["Force magnitude drops ",(0,s.jsx)(e.strong,{children:"after"})," slip is complete:"]}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"t=0s: Grasp established, F=20N (holding force)\nt=1s: Object starts slipping (friction reduces)\nt=1.2s: Object still in contact, F=15N (partial slip)\nt=1.5s: Object fell, F=2N (gripper empty) \u2190 Detected here (too late)\n"})}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Recovery window missed:"})," Object hits ground before detection."]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"B) Detect high-frequency vibrations in force signal (slip-induced oscillations) \u2705"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Correct! Slip causes characteristic vibrations (100-300Hz) before loss of grasp."})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Slip Physics:"})}),(0,s.jsxs)(e.p,{children:["Slip occurs when friction transitions from ",(0,s.jsx)(e.strong,{children:"static"})," to ",(0,s.jsx)(e.strong,{children:"kinetic"}),":"]}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Static friction:"})," Object stuck to gripper, no relative motion"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Kinetic friction:"})," Object sliding, generates stick-slip vibrations"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Vibration Signature:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# Slip detection via high-frequency analysis\nclass SlipDetector:\n    def __init__(self, ft_sensor, sampling_rate=1000):\n        self.ft_sensor = ft_sensor\n        self.fs = sampling_rate\n\n        # Slip frequency range (empirically determined)\n        self.slip_freq_low = 100   # Hz\n        self.slip_freq_high = 300  # Hz\n\n        # Bandpass filter for slip band\n        self.filter = butter_bandpass(self.slip_freq_low, self.slip_freq_high, self.fs)\n\n        # Vibration threshold (calibrated per object)\n        self.vibration_threshold = 0.5  # N RMS\n\n    def detect_slip(self, force_window):\n        """\n        Detect slip from force signal window (100ms = 100 samples).\n\n        Returns: (is_slipping, vibration_magnitude)\n        """\n        # Extract tangential force (perpendicular to grasp axis)\n        f_tangential = force_window[:, :2]  # Fx, Fy (assuming Fz is grasp axis)\n\n        # Apply bandpass filter (100-300 Hz)\n        f_filtered = self.filter.apply(f_tangential)\n\n        # Compute RMS vibration magnitude\n        vibration_rms = np.sqrt(np.mean(f_filtered**2))\n\n        # Threshold detection\n        is_slipping = vibration_rms &gt; self.vibration_threshold\n\n        return is_slipping, vibration_rms\n\n# Real-time slip monitoring\ndef grasp_with_slip_recovery():\n    force_buffer = deque(maxlen=100)  # 100ms window at 1kHz\n\n    while transporting_object:\n        # Read force at 1kHz\n        f_current = ft_sensor.read()\n        force_buffer.append(f_current)\n\n        # Detect slip every 10ms\n        if len(force_buffer) == 100:\n            is_slipping, vibration = slip_detector.detect_slip(force_buffer)\n\n            if is_slipping:\n                # \u2705 Detected slip 200-500ms before object falls\n                print(f"Slip detected! Vibration: {vibration:.2f}N RMS")\n\n                # Recovery action: Increase grip force\n                gripper.increase_force(delta=10N)\n\n                # Slow down motion (reduce acceleration-induced slip)\n                trajectory.scale_velocity(0.5)\n\n                # Re-check after 100ms\n                time.sleep(0.1)\n\n                if not slip_detector.detect_slip(force_buffer):\n                    print("Slip recovered, continuing task")\n                else:\n                    print("Slip persistent, aborting to safe place pose")\n                    move_to_safe_zone()\n                    place_object()\n'})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Frequency Analysis:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# FFT of force signal during slip\ndef analyze_slip_spectrum(force_signal, fs=1000):\n    # Compute FFT\n    fft_result = np.fft.rfft(force_signal)\n    freqs = np.fft.rfftfreq(len(force_signal), 1/fs)\n    magnitude = np.abs(fft_result)\n\n    # Plot spectrum\n    plt.plot(freqs, magnitude)\n    plt.xlabel('Frequency (Hz)')\n    plt.ylabel('Magnitude (N)')\n\n    # Typical slip spectrum:\n    # - DC component: ~10N (mean grasp force)\n    # - 10-50 Hz: Robot motion/vibration (~0.5N)\n    # - 100-300 Hz: Slip vibrations (~2N peak) \u2190 Distinctive signature\n    # - &gt;500 Hz: Sensor noise (~0.1N)\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why This Works:"})}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Early detection:"})," Vibrations start 200-500ms before complete slip"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Robust:"})," Less sensitive to slow force drift (temperature, fatigue)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Object-agnostic:"})," Slip frequency range consistent across materials"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Calibration:"})}),(0,s.jsx)(e.p,{children:"Different objects/grippers have different slip characteristics:"}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Smooth surfaces"})," (glass, metal): Higher frequency (200-400 Hz)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Textured surfaces"})," (rubber, fabric): Lower frequency (50-150 Hz)"]}),"\n"]}),(0,s.jsx)(e.p,{children:"Calibrate threshold by:"}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Induce controlled slip (reduce grip force gradually)"}),"\n",(0,s.jsx)(e.li,{children:"Record force signal during slip"}),"\n",(0,s.jsx)(e.li,{children:"Compute RMS in slip frequency band"}),"\n",(0,s.jsx)(e.li,{children:"Set threshold at 2\xd7 baseline vibration"}),"\n"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"C) Monitor force derivative - detect sudden force drop (dF/dt < -10 N/s)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Unreliable"})," - force derivative is noisy and slip onset is gradual."]}),(0,s.jsx)(e.p,{children:"Force derivative issues:"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Numerical derivative of noisy force signal\ndF_dt = np.diff(force_signal) / dt\n\n# Problems:\n# 1. Sensor noise (\xb10.1N at 1kHz) \u2192 dF/dt = \xb1100 N/s (false positives)\n# 2. Robot motion causes force transients (acceleration \u2192 \xb150 N/s)\n# 3. Slip onset is gradual (dF/dt = -2 N/s), not sudden\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"When derivative helps:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Impact detection (sudden force spike, dF/dt > 100 N/s)"}),"\n",(0,s.jsx)(e.li,{children:"Fast collision events (<10ms duration)"}),"\n"]}),(0,s.jsx)(e.p,{children:"For slip (gradual process), frequency analysis is superior."})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"D) Use tactile sensors on gripper fingers (detect relative motion)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Ideal but requires additional hardware"})," - tactile arrays directly measure slip."]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"BioTac/SynTouch sensors:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Measure contact geometry, force distribution, vibration"}),"\n",(0,s.jsx)(e.li,{children:"Direct slip detection via relative motion sensing"}),"\n",(0,s.jsx)(e.li,{children:"High cost ($2k-5k per finger)"}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Production trade-off:"})}),(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Method"}),(0,s.jsx)(e.th,{children:"Hardware"}),(0,s.jsx)(e.th,{children:"Latency"}),(0,s.jsx)(e.th,{children:"Accuracy"}),(0,s.jsx)(e.th,{children:"Cost"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"F/T sensor + vibration"})}),(0,s.jsx)(e.td,{children:"Standard (included)"}),(0,s.jsx)(e.td,{children:"10-50ms"}),(0,s.jsx)(e.td,{children:"90-95%"}),(0,s.jsx)(e.td,{children:"$0"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Tactile sensors"})}),(0,s.jsx)(e.td,{children:"Additional"}),(0,s.jsx)(e.td,{children:"5-10ms"}),(0,s.jsx)(e.td,{children:"98%+"}),(0,s.jsx)(e.td,{children:"$5k-10k"})]})]})]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Recommendation:"})," Start with F/T vibration detection; add tactile only for high-value applications (surgery, delicate assembly)."]})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"question-10-in-hand-manipulation-energy-efficiency",children:"Question 10: In-Hand Manipulation Energy Efficiency"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"You're comparing two strategies for rotating a screwdriver 90\xb0 in-hand with an Allegro Hand (16 DOF, 4 fingers). Which is more energy-efficient and why?"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Strategy A: Finger Gaiting"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Release middle + ring fingers"}),"\n",(0,s.jsx)(e.li,{children:"Rotate thumb-index pivot 90\xb0"}),"\n",(0,s.jsx)(e.li,{children:"Regrasp with middle + ring at new position"}),"\n",(0,s.jsx)(e.li,{children:"Time: 2.5s, Motor current: 1.2A average"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Strategy B: Continuous Rolling"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"All fingers remain in contact"}),"\n",(0,s.jsx)(e.li,{children:"Coordinated sliding along screwdriver surface"}),"\n",(0,s.jsx)(e.li,{children:"Time: 1.8s, Motor current: 1.8A average"}),"\n"]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"A) Strategy A (finger gaiting) - lower average current (1.2A < 1.8A)"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Incorrect"})," - energy = power \xd7 time, not just current."]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Energy calculation:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Assume 12V motor supply for Allegro Hand\n\n# Strategy A (Finger Gaiting)\nP_A = V \xd7 I_avg = 12V \xd7 1.2A = 14.4W\nE_A = P \xd7 t = 14.4W \xd7 2.5s = 36J\n\n# Strategy B (Continuous Rolling)\nP_B = V \xd7 I_avg = 12V \xd7 1.8A = 21.6W\nE_B = P \xd7 t = 21.6W \xd7 1.8s = 38.9J\n\n# \u2705 Strategy A is slightly more efficient (36J &lt; 38.9J)\n# But the difference is marginal (7.5%)\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"However, this ignores:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Regrasping force spikes:"})," Gaiting requires high force pulses to re-establish grip"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Gravity compensation:"})," Holding screwdriver with 2 fingers (vs 4) requires higher normal force"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Computation cost:"})," Grasp planning + IK for regrasp pose"]}),"\n"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"B) Strategy B (continuous rolling) - faster completion (1.8s < 2.5s) despite higher current \u2705"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Correct (with caveat)! Continuous rolling is more energy-efficient when accounting for all factors."})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Complete Energy Analysis:"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Strategy A (Finger Gaiting):"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Phase 1: Release middle+ring (0.3s)\nE_release = (0.5A \xd7 12V) \xd7 0.3s = 1.8J  # Low force\n\n# Phase 2: Rotate thumb-index pivot (1.5s)\n# Higher force needed (only 2 fingers holding)\nE_rotate = (1.8A \xd7 12V) \xd7 1.5s = 32.4J  # High current\n\n# Phase 3: Regrasp middle+ring (0.5s)\n# Force spike to establish contact\nE_regrasp = (2.5A \xd7 12V) \xd7 0.5s = 15J  # Peak current\n\n# Phase 4: Stabilize (0.2s)\nE_stabilize = (1.0A \xd7 12V) \xd7 0.2s = 2.4J\n\n# Total\nE_A_total = 1.8 + 32.4 + 15 + 2.4 = 51.6J\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Strategy B (Continuous Rolling):"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# All fingers in contact \u2192 load distributed \u2192 lower normal force per finger\n\n# Phase 1: Establish rolling contact (0.2s)\nE_setup = (1.5A \xd7 12V) \xd7 0.2s = 3.6J\n\n# Phase 2: Coordinated rolling (1.6s)\n# Constant moderate force (friction + object weight)\nE_rolling = (1.8A \xd7 12V) \xd7 1.6s = 34.6J\n\n# Total\nE_B_total = 3.6 + 34.6 = 38.2J\n\n# \u2705 Strategy B: 38.2J (26% less energy than Strategy A)\n"})}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why Continuous Rolling is More Efficient:"})}),(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Load distribution:"})," 4 fingers share object weight \u2192 lower normal force per finger"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Gaiting: F_normal = (0.5kg \xd7 9.8) / 2 fingers = 2.45N per finger"}),"\n",(0,s.jsx)(e.li,{children:"Rolling: F_normal = (0.5kg \xd7 9.8) / 4 fingers = 1.23N per finger"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"No regrasping spikes:"})," Avoiding peak force reduces energy"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Gaiting: 2.5A peak current for 0.5s"}),"\n",(0,s.jsx)(e.li,{children:"Rolling: Smooth 1.8A throughout"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Friction mechanics:"}),' Sliding friction < static friction (rolling reduces "stick")']}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"\u03bc_static \u2248 0.7 (gaiting: static grasp)"}),"\n",(0,s.jsx)(e.li,{children:"\u03bc_kinetic \u2248 0.5 (rolling: controlled slide)"}),"\n"]}),"\n"]}),"\n"]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Trade-offs:"})}),(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Metric"}),(0,s.jsx)(e.th,{children:"Gaiting"}),(0,s.jsx)(e.th,{children:"Rolling"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Energy"})}),(0,s.jsx)(e.td,{children:"51.6J"}),(0,s.jsx)(e.td,{children:"38.2J \u2705"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Time"})}),(0,s.jsx)(e.td,{children:"2.5s"}),(0,s.jsx)(e.td,{children:"1.8s \u2705"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Control complexity"})}),(0,s.jsx)(e.td,{children:"Simple (2 discrete grasps)"}),(0,s.jsx)(e.td,{children:"High (coordinated 16-DOF)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Robustness"})}),(0,s.jsx)(e.td,{children:"High (stable discrete grasps)"}),(0,s.jsx)(e.td,{children:"Moderate (slip risk)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Tactile sensing"})}),(0,s.jsx)(e.td,{children:"Optional"}),(0,s.jsxs)(e.td,{children:[(0,s.jsx)(e.strong,{children:"Required"})," (detect slip)"]})]})]})]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Production Recommendation:"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"With tactile sensing:"})," Use continuous rolling (faster, more efficient)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Without tactile sensing:"})," Use finger gaiting (more robust, acceptable energy cost)"]}),"\n"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"C) Equal efficiency - energy depends only on rotation angle (90\xb0), not strategy"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Incorrect"})," - work done on object is same, but motor losses differ."]}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Object energy"})," (conservative force field):"]}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Work to rotate screwdriver against friction\nW_object = \u03c4_friction \xd7 \u03b8 = (0.05 Nm) \xd7 (\u03c0/2 rad) = 0.08J\n\n# \u2705 This is the same for both strategies\n"})}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Motor energy"})," (includes losses):"]}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Motor efficiency \u2248 60-80% (heat, friction, back-EMF)\n# E_motor = W_object / \u03b7 + E_control\n\n# Gaiting: Higher peak forces \u2192 lower instantaneous efficiency\n\u03b7_gaiting \u2248 60% \u2192 E_motor_A = 0.08J / 0.6 = 0.13J (mechanical) + 51J (control) = 51.13J\n\n# Rolling: Smoother force profile \u2192 higher average efficiency\n\u03b7_rolling \u2248 75% \u2192 E_motor_B = 0.08J / 0.75 = 0.11J (mechanical) + 38J (control) = 38.11J\n"})}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Key insight:"})," Control energy (holding, regrasping) dominates object work by 500\xd7!"]})]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:"D) Depends on friction coefficient - need tactile data to determine"}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Partially correct"})," - friction does affect energy, but comparative analysis still holds."]}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Sensitivity analysis:"})}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Energy vs friction coefficient\ndef compute_energy(mu, strategy):\n    if strategy == 'gaiting':\n        # Normal force higher (2 fingers)\n        F_normal = object_weight / 2\n        E = F_normal * mu * distance + E_regrasping\n    elif strategy == 'rolling':\n        # Normal force lower (4 fingers)\n        F_normal = object_weight / 4\n        E = F_normal * mu * distance\n\n# Results:\n# \u03bc=0.3 (low): E_gaiting=48J, E_rolling=35J (rolling 27% better)\n# \u03bc=0.7 (med): E_gaiting=52J, E_rolling=38J (rolling 27% better)\n# \u03bc=1.2 (high): E_gaiting=58J, E_rolling=43J (rolling 26% better)\n\n# \u2705 Rolling is consistently more efficient across friction range\n"})}),(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Conclusion:"})," While friction coefficient affects absolute energy, the ",(0,s.jsx)(e.strong,{children:"relative advantage"})," of rolling (26-27%) is robust."]})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Key Concepts Tested:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Grasp Quality:"})," Ferrari-Canny metric balances alignment, width utilization, wrench space"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"IK Convergence:"})," Local minima solved by multi-start random seeding"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Impedance Control:"})," Anisotropic stiffness for constrained tasks (USB insertion)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Grasp Synergies:"})," Precision grasp (S1+S2) enables in-hand manipulation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"IK Solver Selection:"})," TRAC-IK optimal for production (speed + reliability)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision Geometry:"})," False positives from excessive padding (reduce to 3-5mm)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dual-Arm Coordination:"})," Relative Jacobian enforces tray levelness"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Adaptive Control:"})," Admittance control for stiff environments (door opening)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Slip Detection:"})," High-frequency vibration analysis (100-300 Hz)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Energy Efficiency:"})," Continuous rolling > finger gaiting (load distribution + no regrasping)"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Production Best Practices:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Grasp Planning:"})," Target 60-80% gripper width for robustness"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"IK Solving:"})," TRAC-IK with 50ms timeout, 3 attempts"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Impedance Tuning:"})," Anisotropic stiffness (stiff lateral, soft axial)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force Control:"})," 200Hz+ control rate, adaptive stiffness based on contact"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Failure Recovery:"})," Visualize collisions, reduce padding, multi-modal grasps"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Slip Prevention:"})," 1kHz F/T sampling, bandpass filter (100-300 Hz), 10N recovery force"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Next Chapter:"})," Chapter 10 - Whole-Body Motion Planning (integrating locomotion + manipulation)"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>o});var r=i(6540);const s={},t=r.createContext(s);function l(n){const e=r.useContext(t);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);